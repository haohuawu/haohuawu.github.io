<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><title>DOM 事件模型详解</title><meta name="description" content="事件监听方式HTML 内联属性监听1&amp;lt;button onclick=&quot;handleClick(event || window.event)&quot;&amp;gt;&amp;lt;/button&amp;gt;不推荐该方法：javascript 与 HTML 耦合，不便于维护；handleClick 必须定义在 window 对象上；同时 handleClick 函数内部的 this 默认指向 window 而非当前监听事"><meta property="og:type" content="article"><meta property="og:title" content="DOM 事件模型详解"><meta property="og:url" content="https://haohuawu.github.io/2017/03/25/dom-event/index.html"><meta property="og:site_name" content="天枢"><meta property="og:description" content="事件监听方式HTML 内联属性监听1&amp;lt;button onclick=&quot;handleClick(event || window.event)&quot;&amp;gt;&amp;lt;/button&amp;gt;不推荐该方法：javascript 与 HTML 耦合，不便于维护；handleClick 必须定义在 window 对象上；同时 handleClick 函数内部的 this 默认指向 window 而非当前监听事"><meta property="og:image" content="https://haohuawu.github.io/assets/images/DOM-event-propagation.png"><meta property="og:updated_time" content="2017-05-30T12:59:58.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="DOM 事件模型详解"><meta name="twitter:description" content="事件监听方式HTML 内联属性监听1&amp;lt;button onclick=&quot;handleClick(event || window.event)&quot;&amp;gt;&amp;lt;/button&amp;gt;不推荐该方法：javascript 与 HTML 耦合，不便于维护；handleClick 必须定义在 window 对象上；同时 handleClick 函数内部的 this 默认指向 window 而非当前监听事"><meta name="twitter:image" content="https://haohuawu.github.io/assets/images/DOM-event-propagation.png"><link rel="stylesheet" href="/assets/blog/styles/main.css"></head><body><header class="site--header" role="banner"><div class="wrapper"><a class="site--title" href="/">天枢</a> <a class="nav-menu" href="javascript: void 0;"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 32"><path fill="#424242" d="M2 6.667h28v3.135h-28v-3.135zM2 17.531v-3.063h28v3.063h-28zM2 25.333v-3.135h28v3.135h-28z"></path></svg></a></div></header><main class="site--content" aria-label="Content"><div class="wrapper"><article id="post-dom-event" class="post" data-layout="post" data-site-index="post" itemscope itemprop="blogPost"><!-- title --><h1 class="post-title" itemprop="name">DOM 事件模型详解</h1><!-- meta --><div class="post-meta"><span class="post-date post-meta--item"><span class="icon icon---date"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28"><path fill="#828282" d="M14.714 7.049v7.275l6.236 3.703-1.039 1.754-7.275-4.417v-8.315h2.079zM14 25.108c6.106 0 11.108-5.002 11.108-11.108s-5.002-11.108-11.108-11.108-11.108 5.002-11.108 11.108 5.002 11.108 11.108 11.108zM14 0.164c7.665 0 13.836 6.171 13.836 13.836s-6.171 13.836-13.836 13.836-13.836-6.171-13.836-13.836 6.171-13.836 13.836-13.836z"></path></svg> </span><time datetime="2017-03-25T02:24:41.000Z" itemprop="datePublished">2017-03-25</time></span><div class="post-tags post-meta--item"><span class="icon icon---tag"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28"><path fill="#828282" d="M26.688 0h-10.5c-0.722 0-1.73 0.418-2.241 0.928l-13.019 13.019c-0.51 0.51-0.51 1.346 0 1.856l11.269 11.269c0.51 0.51 1.346 0.51 1.856 0l13.019-13.019c0.51-0.51 0.928-1.519 0.928-2.241v-10.5c0-0.722-0.591-1.313-1.313-1.313zM20.125 10.5c-1.45 0-2.625-1.175-2.625-2.625s1.175-2.625 2.625-2.625 2.625 1.175 2.625 2.625-1.175 2.625-2.625 2.625z"></path></svg></span><ul class="tag-list"><li class="tag-list--item"><a class="tag-list--link" href="/tags/html/">#HTML</a></li><li class="tag-list--item"><a class="tag-list--link" href="/tags/event-propagation/">#Event Propagation</a></li></ul></div></div><!-- gallery --><!-- entry --><main class="post--entry" itemprop="articleBody"><h3 id="事件监听方式"><a href="#事件监听方式" class="headerlink" title="事件监听方式"></a>事件监听方式</h3><h4 id="HTML-内联属性监听"><a href="#HTML-内联属性监听" class="headerlink" title="HTML 内联属性监听"></a>HTML 内联属性监听</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"handleClick(event || window.event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure><p>不推荐该方法：javascript 与 HTML 耦合，不便于维护；handleClick 必须定义在 window 对象上；同时 handleClick 函数内部的 this 默认指向 window 而非当前监听事件的元素。因此，除非有特殊需求（比如 BI 埋点）一般不使用该方法监听事件。</p><h4 id="DOM-属性绑定"><a href="#DOM-属性绑定" class="headerlink" title="DOM 属性绑定"></a>DOM 属性绑定</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element.onclick = <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>同样不推荐该方法监听事件，因为该方法不支持监听多次事件回调（虽然可以自己封装，但很麻烦）</p><h4 id="事件监听函数"><a href="#事件监听函数" class="headerlink" title="事件监听函数"></a>事件监听函数</h4><p>添加事件监听</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element.addEventListener(<span class="string">'click'</span>, handleClick, <span class="literal">false</span>);</div></pre></td></tr></table></figure><p>移除事件监听</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element.removeEventListener(<span class="string">'click'</span>, handleClick, <span class="literal">false</span>);</div></pre></td></tr></table></figure><h3 id="事件传播模型"><a href="#事件传播模型" class="headerlink" title="事件传播模型"></a>事件传播模型</h3><p>先来看个 Demo</p><script async src="//jsfiddle.net/wuhaohua/u99xnk3u/embed/js,html,result/"></script><p>点击 child1，打开控制台，将输出：</p><p><img src="/assets/images/DOM-event-propagation.png" alt="demo"></p><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">---------------| |-----------------</div><div class="line">| element1     | |                |</div><div class="line">|   -----------| |-----------     |</div><div class="line">|   |element2  \ /          |     |</div><div class="line">|   -------------------------     |</div><div class="line">|        Event CAPTURING          |</div><div class="line">-----------------------------------</div></pre></td></tr></table></figure><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">               / \</div><div class="line">---------------| |-----------------</div><div class="line">| element1     | |                |</div><div class="line">|   -----------| |-----------     |</div><div class="line">|   |element2  | |          |     |</div><div class="line">|   -------------------------     |</div><div class="line">|        Event BUBBLING           |</div><div class="line">-----------------------------------</div></pre></td></tr></table></figure><p>想当年，网景主张事件捕获、微软主张事件冒泡（IE &lt; 9 只支持事件冒泡），而 W3C 采用了折中的方式：先捕获再冒泡</p><h4 id="阻止事件传播"><a href="#阻止事件传播" class="headerlink" title="阻止事件传播"></a>阻止事件传播</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">event.stopPropagation(); // 阻止事件继续捕获或者冒泡</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">event.stopImmediatePropagation(); // 阻止调用该事件的其他事件监听</div></pre></td></tr></table></figure><h4 id="阻止默认事件行为"><a href="#阻止默认事件行为" class="headerlink" title="阻止默认事件行为"></a>阻止默认事件行为</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">event.preventDefault();</div></pre></td></tr></table></figure><p>preventDefault 方法取消浏览器对当前事件的默认行为，比如点击链接后，浏览器跳转到指定页面，或者按一下空格键，页面向下滚动一段距离。该方法生效的前提是，事件的cancelable属性为true，如果为false，则调用该方法没有任何效果。</p><h4 id="事件代理-委托"><a href="#事件代理-委托" class="headerlink" title="事件代理/委托"></a>事件代理/委托</h4><p>事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理。当子节点动态的插入 DOM 时，使用事件代理能避免对子元素进行频繁的事件注册，更加高效。</p><h3 id="事件常见属性"><a href="#事件常见属性" class="headerlink" title="事件常见属性"></a>事件常见属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">bubbles</span>: boolean, <span class="comment">// 是否是在冒泡阶段触发的</span></div><div class="line">  type: DOMString, <span class="comment">// 事件类型, 'click', 'touchstart'</span></div><div class="line">  target: EventTarget, <span class="comment">// 事件目标节点（事件源）</span></div><div class="line">  currentTarget: EventTarget, <span class="comment">// 事件监听节点</span></div><div class="line">  eventPhase: unsigned short, <span class="comment">// 事件传播阶段</span></div><div class="line">  defaultPrevented: boolean, <span class="comment">// 是否调用过 preventDefault</span></div><div class="line">  isTrusted: boolean <span class="comment">// 事件是否由用户交互触发</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="事件的执行顺序"><a href="#事件的执行顺序" class="headerlink" title="事件的执行顺序"></a>事件的执行顺序</h3><p>正常情况下，先捕获后冒泡，而当事件源为当前事件目标时，并且同一个事件，同一个元素在不同事件传播阶段都绑定了监听，则取决于事件注册顺序，谁先注册，谁先执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">parent.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>);</div><div class="line">&#125;, <span class="literal">false</span>);</div><div class="line">parent.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获'</span>);</div><div class="line">&#125;, <span class="literal">true</span>);</div></pre></td></tr></table></figure><p>点击 parent，则输出:</p><p>冒泡<br>捕获</p><h3 id="事件-this-指向"><a href="#事件-this-指向" class="headerlink" title="事件 this 指向"></a>事件 this 指向</h3><p>如果事件回调没有使用 <code>Function.prototype.bind</code> 的话，this 一般指向 currentTarget、全局对象（window、undefined等）</p><p>this 指向 element 节点：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// JavaScript代码</div><div class="line">element.onclick = print</div><div class="line">element.addEventListener(&apos;click&apos;, print, false)</div><div class="line">element.onclick = function () &#123;console.log(this.id);&#125;</div><div class="line"></div><div class="line">// HTML代码</div><div class="line">&lt;element onclick=&quot;console.log(this.id)&quot;&gt;</div></pre></td></tr></table></figure><p></p><p>this 指向全局对象<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// JavaScript代码</div><div class="line">element.onclick = function ()&#123; doSomething() &#125;;</div><div class="line">element.setAttribute(&apos;onclick&apos;, &apos;doSomething()&apos;);</div><div class="line"></div><div class="line">// HTML代码</div><div class="line">&lt;element onclick=&quot;doSomething()&quot;&gt;</div></pre></td></tr></table></figure><p></p><h3 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h3><p>这里的浏览器兼容问题主要在于 IE 8 及其以下与其他浏览器的差别</p><ul><li>监听事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (element.attachEvent) &#123; <span class="comment">// IE &lt; 9</span></div><div class="line">  element.attachEvent(<span class="string">'click'</span>, handleClick);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  element.addEventListener(<span class="string">'click'</span>, handleClick, <span class="literal">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>触发事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (element.fireEvent) &#123; <span class="comment">// IE &lt; 9</span></div><div class="line">  element.fireEvent(<span class="string">'click'</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  element.dispatchEvent(<span class="string">'click'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>事件源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const target = event.target || event.srcElement;</div></pre></td></tr></table></figure><ul><li>获取事件对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">event = event || window.event</div></pre></td></tr></table></figure><h3 id="常用事件和技巧"><a href="#常用事件和技巧" class="headerlink" title="常用事件和技巧"></a>常用事件和技巧</h3><ul><li>beforeunload</li></ul><p>当浏览者在页面上的输入框输入一些内容时，未保存、误操作关掉网页可能会导致输入信息丢失，这时我们可以监听该事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">window.addEventListener(&apos;beforeunload&apos;, function(event) &#123;</div><div class="line">  event.returnValue = &apos;放弃当前未保存内容而关闭页面？&apos;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><ul><li>resize, scroll</li></ul><p>当用户调整窗口大小或者滚动内容时，将触发大量的事件，如果事件回调比较耗时，那么大量的调用将会卡顿用户界面。我们可以通过函数节流或者去抖动函数将大量的事件触发整合成较少的函数调用</p><ul><li>error</li></ul><p>当加载资源失败或者加载成功但是只加载一部分而无法使用时，就会触发 error 事件，我们可以利用该事件对资源加载做容错处理，比如给图片加占位图。</p><h3 id="自定义事件-CustomEvent-IE-9"><a href="#自定义事件-CustomEvent-IE-9" class="headerlink" title="自定义事件 CustomEvent (IE 9+)"></a>自定义事件 CustomEvent (IE 9+)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const event = document.createEvent(&apos;CustomEvent&apos;); // deprecated, use new CustomEvent() instead in modern browsers</div><div class="line">event.initCustomEvent(type, canBubble, cancelable, detail);</div><div class="line">element.dispatchEvent(event);</div></pre></td></tr></table></figure><p>参考</p><ul><li><a href="https://stackoverflow.com/questions/4616694/what-is-event-bubbling-and-capturing" target="_blank" rel="external">what-is-event-bubbling-and-capturing</a></li><li><a href="http://javascript.ruanyifeng.com/dom/event.html" target="_blank" rel="external">JavaScript 标准参考教程（alpha）- 事件模型, by 阮一峰</a></li><li><a href="https://www.quirksmode.org/js/events_order.html" target="_blank" rel="external">Events Order</a></li><li><a href="https://dom.spec.whatwg.org/#event" target="_blank" rel="external">DOM Event Spec</a></li></ul></main><!-- navigation --><nav class="post-nav"><a href="/2017/03/28/talking-about-css-architecture/" class="post-nav--link"><strong class="post-nav--caption">上一篇</strong><div class="post-nav--title">谈谈 CSS 架构</div></a><a href="/2017/03/15/setup-fe-server/" class="post-nav--link"><strong class="post-nav--caption">下一篇</strong><div class="post-nav--title">搭建前端开发 Ubuntu 服务器</div></a></nav><!-- footer --></article><aside class="side-bar"><div class="side-bar--wrapper"><nav class="post-nav"><a href="/2017/03/28/talking-about-css-architecture/" class="post-nav--link"><strong class="post-nav--caption">上一篇</strong> </a><a href="/2017/03/15/setup-fe-server/" class="post-nav--link"><strong class="post-nav--caption">下一篇</strong></a></nav><!-- toc --><ul class="toc"><li class="toc--item"><a title="事件监听方式" class="toc--item--anchor" href="#事件监听方式" data-depth="0"><span class="toc--number">1</span>事件监听方式</a></li><li class="toc--item"><a title="HTML 内联属性监听" class="toc--item--anchor" href="#HTML-内联属性监听" data-depth="1"><span class="toc--number">1.1</span>HTML 内联属性监听</a></li><li class="toc--item"><a title="DOM 属性绑定" class="toc--item--anchor" href="#DOM-属性绑定" data-depth="1"><span class="toc--number">1.2</span>DOM 属性绑定</a></li><li class="toc--item"><a title="事件监听函数" class="toc--item--anchor" href="#事件监听函数" data-depth="1"><span class="toc--number">1.3</span>事件监听函数</a></li><li class="toc--item"><a title="事件传播模型" class="toc--item--anchor" href="#事件传播模型" data-depth="0"><span class="toc--number">2</span>事件传播模型</a></li><li class="toc--item"><a title="事件捕获" class="toc--item--anchor" href="#事件捕获" data-depth="1"><span class="toc--number">2.1</span>事件捕获</a></li><li class="toc--item"><a title="事件冒泡" class="toc--item--anchor" href="#事件冒泡" data-depth="1"><span class="toc--number">2.2</span>事件冒泡</a></li><li class="toc--item"><a title="阻止事件传播" class="toc--item--anchor" href="#阻止事件传播" data-depth="1"><span class="toc--number">2.3</span>阻止事件传播</a></li><li class="toc--item"><a title="阻止默认事件行为" class="toc--item--anchor" href="#阻止默认事件行为" data-depth="1"><span class="toc--number">2.4</span>阻止默认事件行为</a></li><li class="toc--item"><a title="事件代理/委托" class="toc--item--anchor" href="#事件代理-委托" data-depth="1"><span class="toc--number">2.5</span>事件代理/委托</a></li><li class="toc--item"><a title="事件常见属性" class="toc--item--anchor" href="#事件常见属性" data-depth="0"><span class="toc--number">3</span>事件常见属性</a></li><li class="toc--item"><a title="事件的执行顺序" class="toc--item--anchor" href="#事件的执行顺序" data-depth="0"><span class="toc--number">4</span>事件的执行顺序</a></li><li class="toc--item"><a title="事件 this 指向" class="toc--item--anchor" href="#事件-this-指向" data-depth="0"><span class="toc--number">5</span>事件 this 指向</a></li><li class="toc--item"><a title="浏览器兼容" class="toc--item--anchor" href="#浏览器兼容" data-depth="0"><span class="toc--number">6</span>浏览器兼容</a></li><li class="toc--item"><a title="常用事件和技巧" class="toc--item--anchor" href="#常用事件和技巧" data-depth="0"><span class="toc--number">7</span>常用事件和技巧</a></li><li class="toc--item"><a title="自定义事件 CustomEvent (IE 9+)" class="toc--item--anchor" href="#自定义事件-CustomEvent-IE-9" data-depth="0"><span class="toc--number">8</span>自定义事件 CustomEvent (IE 9+)</a></li></ul></div></aside></div></main><footer class="site--footer"><div class="wrapper"><h2 class="footer--heading">天枢</h2><div class="footer-col-wrapper"><div class="footer-col footer-col---3"><ul class="slash-list"><li>他强由他强，清风拂山岗</li><li><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="知识共享许可协议" style="border-width: 0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/80x15.png"></a></li></ul></div></div></div></footer><script src="/assets/blog/js/manifest.js"></script><script src="/assets/blog/js/vendor.js"></script><script src="/assets/blog/js/main.js"></script></body></html>